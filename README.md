# Crankshaft CAN Control for Audi RNS-E MMI
## Purpose

This project allows controlling a Raspberry Pi running Crankshaft NG (an Android Auto & CarPlay head unit software) using the MMI (Multi Media Interface) controls connected to an Audi RNS-E navigation unit via the vehicle's Infotainment CAN bus (100 kbit/s).

It listens for specific CAN messages generated by the MMI buttons and knob when the RNS-E is in a compatible mode (e.g., TV/Video-In) and translates these messages into simulated keyboard presses using `xdotool`. Crankshaft then interprets these key presses for navigation and control within Android Auto or CarPlay.

## How it Works

1.  **MMI Input:** User interacts with the RNS-E MMI controls (knob press/turn, buttons).
2.  **CAN Message:** The RNS-E sends specific CAN messages (ID `0x461` on the Infotainment bus) corresponding to the MMI actions.
3.  **CAN HAT Reception:** A Raspberry Pi equipped with an MCP2515-based CAN HAT receives these messages via the `can0` interface.
4.  **Python Script:** A Python script (`can_keyboard_control.py`) running on the Pi listens for messages with ID `0x461`.
5.  **Message Parsing:** The script decodes the relevant data bytes from the CAN message to identify the specific MMI action.
6.  **Keyboard Simulation:** The script uses `xdotool` to simulate a corresponding keyboard press (e.g., Arrow keys, Enter, custom keys like '1', '2').
7.  **Crankshaft Control:** Crankshaft (and the underlying Android Auto / CarPlay session) receives the simulated key press and performs the associated action (e.g., navigate menu, select item).

## Requirements

### Hardware

* Raspberry Pi (3B+ or 4 recommended) running Crankshaft NG.
* MCP2515-based CAN HAT (e.g., PiCAN2, Waveshare CAN HAT, or similar).
* Audi RNS-E Navigation Unit (or a compatible test bench setup).
* Connection to the Audi Infotainment CAN bus (100 kbit/s). Typically available at the RNS-E Quadlock Connector D, Pin 9 (CAN-H) and Pin 10 (CAN-L).
* Appropriate wiring and power supplies.

### Software

* Crankshaft NG distribution installed on the Raspberry Pi SD card.
* SSH access or a terminal on the Raspberry Pi.
* Required packages: `can-utils`, `xdotool`, `python3`, `python3-pip`.
* Required Python library: `python-can`.

## Setup Instructions

**Step 1: Connect Hardware & Enable SPI**

1.  Shut down the Raspberry Pi and correctly install the CAN HAT onto the GPIO pins.
2.  Connect the CAN HAT's CAN-H and CAN-L terminals to the vehicle's/RNS-E's Infotainment CAN bus (100 kbit/s). Ensure correct polarity. Verify bus termination (usually, the termination jumper/switch on the HAT should be **OFF** as the RNS-E and Instrument Cluster provide termination).
3.  Power up the Raspberry Pi.
4.  Open a terminal and run `sudo raspi-config`.
5.  Navigate to `Interface Options` -> `SPI`.
6.  Select `Yes` to enable the SPI interface.
7.  Exit `raspi-config`.

**Step 2: Configure Device Tree Overlay (DTO)**

1.  Edit the boot configuration file. The path might be `/boot/config.txt` or `/boot/firmware/config.txt` on newer systems:
    Make the boot partition writeable:

    ```bash
    sudo mount -o remount,rw /boot
    # OR possibly:
    # sudo sudo mount -o remount,rw /boot/firmware
    ```
    *only one will work

    ```bash
    sudo nano /boot/config.txt
    # OR possibly:
    # sudo nano /boot/firmware/config.txt
    ```
3.  Add the following lines at the end of the file.
    **IMPORTANT:** Replace `YOUR_OSCILLATOR_HZ` with the frequency of the crystal oscillator on your specific HAT in Hz (e.g., `8000000`, `12000000` or `16000000`) and `YOUR_INTERRUPT_PIN` with the GPIO pin number your HAT uses for interrupts (often `23` or `25`). **Consult your HAT's documentation for these values! Incorrect values will cause CAN errors.**
    ```text
    # --- MCP2515 CAN HAT ---
    dtparam=spi=on
    dtoverlay=mcp2515-can0,oscillator=YOUR_OSCILLATOR_HZ,interrupt=YOUR_INTERRUPT_PIN,spimaxfrequency=1000000
    ```
4.  Save the file and exit (`Ctrl+O`, `Enter`, `Ctrl+X`).

5.  Make the boot partition only readable:

    ```bash
    sudo mount -o remount,ro /boot
    # OR
    # sudo mount -o remount,ro /boot/firmware
    ```

6.  Reboot the Raspberry Pi for the changes to take effect:
    
    ```bash
    sudo reboot
    ```

**Step 3: Install Software Dependencies**

1.  **Enable Write Access:** Crankshaft NG often uses a read-only filesystem. Remount as read-write:
    
    ```bash
    sudo mount -o remount,rw /
    ```

2.  **Update Package Lists:**
    
    ```bash
    sudo apt update
    ```

3.  **Install Required Packages:**
    
    ```bash
    sudo apt install can-utils xdotool python3-pip
    ```

4.  **Install Python CAN Library (System-wide):**
    
    ```bash
    sudo python3 -m pip install --upgrade pip
    sudo python3 -m pip install --force-reinstall python-can
    ```

**Step 4: Create Python Control Script**

1.  Create the script file in the `pi` user's home directory:

    ```bash
    nano /home/pi/can_keyboard_control.py
    ```

2.  Paste the Python code into the editor or transfer the file to the Pi

3.  Save the file and exit (`Ctrl+O`, `Enter`, `Ctrl+X`).

**Step 5: Correct Script Ownership**

1.  Ensure the script is owned by the `pi` user (as it might have been created with `sudo nano`):

    ```bash
    sudo chown pi:pi /home/pi/can_keyboard_control.py
    ```

**Step 6: Create systemd Service for CAN Interface**

1.  Create the service file (ensure filesystem is read-write if not already):

    ```bash
    # sudo mount -o remount,rw / # If needed
    sudo nano /etc/systemd/system/configure-can0.service
    ```

2.  Paste the following content:

    ```ini
    [Unit]
    Description=Configure can0 Interface (100kbit/s)
    After=network.target network-online.target
    Wants=network-online.target

    [Service]
    Type=oneshot
    RemainAfterExit=yes
    ExecStart=/sbin/ip link set can0 up type can bitrate 100000

    [Install]
    WantedBy=multi-user.target
    ```

3.  Save and exit.

**Step 7: Create systemd Service for Python Script**

1.  Create the service file:

    ```bash
    # sudo mount -o remount,rw / # If needed
    sudo nano /etc/systemd/system/can-keyboard.service
    ```

2.  Paste the following content (comment-free version, paths for `pi` user):

    ```ini
    [Unit]
    Description=CAN Keyboard Control Service (Audi RNS-E)
    Requires=configure-can0.service
    After=configure-can0.service graphical.target

    [Service]
    User=pi
    Group=pi
    WorkingDirectory=/home/pi/
    Environment="DISPLAY=:0"
    Environment="XAUTHORITY=/home/pi/.Xauthority"
    ExecStart=/usr/bin/python3 /home/pi/can_keyboard_control.py
    Restart=on-failure
    RestartSec=5

    [Install]
    WantedBy=graphical.target
    ```

3.  Save and exit.

**Step 8: Finalize systemd Configuration**

1.  Reload the systemd daemon:

    ```bash
    sudo systemctl daemon-reload
    ```

2.  Enable both services to start on boot:

    ```bash
    sudo systemctl enable configure-can0.service
    sudo systemctl enable can-keyboard.service
    ```

3.  (Optional) Verify they are enabled:

    ```bash
    sudo systemctl is-enabled configure-can0.service
    sudo systemctl is-enabled can-keyboard.service
    ```

    *(Both should output `enabled`)*.

**Step 9: Reboot & Verify**

1.  Reboot the Raspberry Pi:

    ```bash
    sudo reboot
    ```

2.  After reboot and Crankshaft startup, check via SSH or terminal:
    * Verify CAN interface status (should be UP, 100kbit/s, check error state):

        ```bash
        ip -details link show can0
        ```

    * Verify Python script service status (should be active and running):

        ```bash
        systemctl status can-keyboard.service
        ```

    * (If needed) Check script logs: `journalctl -u can-keyboard.service`

**Step 10: Functional Test**

1.  Connect the Pi to the car's CAN bus or test bench.
2.  Start Crankshaft / Android Auto / CarPlay.
3.  Operate the RNS-E MMI controls and verify the corresponding actions occur in Crankshaft.

**Step 11: Set Filesystem Read-Only**

1.  Once everything works as expected, set the filesystem back to read-only for stability in the car:

    ```bash
    sudo mount -o remount,ro /
    ```
**Step 12: Analoge Video Output**

To use the 3,5mm jack for video output, replace the config.txt on the SD Card or edit it like this way:
    * If you replace it, don't forget to set `YOUR_INTERRUPT_PIN` and `YOUR_OSCILLATOR_HZ` with values matching your HAT

Add this in `pi4` or at the beginning of `all`. It's configured for PAL by `setting sdtv_mode` to 2.

```Plaintext
enable_tvout=1
sdtv_mode=2
sdtv_aspect=3
dtoverlay=vc4-fkms-v3d,composite=1
# Ggf. hdmi_ignore_hotplug=1
```

## Configuration

The main parts to configure in `/home/pi/can_keyboard_control.py` are:

* `CAN_INTERFACE`: Should usually be `can0`.
* `TARGET_CAN_ID`: Set to `0x461` for the RNS-E MMI controls.
* `COMMAND_TO_KEY`: This dictionary maps the received CAN data (as a tuple of decimal values from Byte 3 and Byte 4) to the desired `xdotool` key names. Adjust the key names if different keyboard actions are desired.

## Troubleshooting / Notes

* **CAN Errors (`ERROR-ACTIVE`/`ERROR-PASSIVE`):** If `ip -details link show can0` shows persistent error states after reboot, double-check:
    * The `oscillator` and `interrupt` values in `/boot/config.txt` **exactly** match your CAN HAT specifications. This is critical for correct bit timing.
    * The CAN bus **termination** is correct (~60 Ohms between CAN-H and CAN-L when powered down). Ensure the Pi HAT's termination is disabled unless it's at a physical end of the bus.
    * The **bitrate** (100000) is correct for all devices on the Infotainment CAN bus.
    * Wiring, especially **CAN-H/CAN-L polarity** and a **common ground** connection.
* **`xdotool` Errors:** If the script runs but key presses don't work, check the service logs (`journalctl -u can-keyboard.service`) for `xdotool` errors. Ensure the `DISPLAY` and `XAUTHORITY` environment variables in `can-keyboard.service` are correct for your Crankshaft setup.
* **Key Mapping:** The key mapping provided targets specific actions observed with RNS-E controls. Using non-standard keys like '1', '2' might have varying results in different Android Auto / CarPlay apps compared to standard keys like `Left`, `Right`. Adjust the `COMMAND_TO_KEY` dictionary as needed based on testing.

## Disclaimer

Modifying vehicle CAN bus systems carries risks. Ensure you understand the implications before connecting any custom hardware. Incorrect connections or messages could potentially interfere with vehicle operation. Use this project at your own risk.

---
